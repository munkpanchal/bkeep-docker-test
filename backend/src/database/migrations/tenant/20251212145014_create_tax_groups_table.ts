import type { Knex } from 'knex'

/**
 * Create tax_groups and tax_group_taxes tables migration
 * Tenant-specific tables for tax group configurations
 * Tax groups allow combining multiple taxes (e.g., GST + PST)
 * This migration should only be run in tenant schemas, not in public schema
 */
export async function up(knex: Knex): Promise<void> {
  // Create tax_groups table
  await knex.schema.createTable('tax_groups', (table) => {
    // Primary key - UUID
    // Note: UUID is generated by BaseModel.$beforeInsert() using uuidv4()
    // No database default needed as application handles UUID generation
    table.uuid('id').primary()

    // Tenant reference
    table
      .uuid('tenant_id')
      .notNullable()
      .references('id')
      .inTable('public.tenants')
      .onDelete('CASCADE')
      .comment('Reference to the tenant this tax group belongs to')

    // Tax group fields
    table
      .string('name', 255)
      .notNullable()
      .comment('Tax group name (e.g., "GST + PST", "HST")')

    table.text('description').nullable().comment('Description of the tax group')

    table
      .boolean('is_active')
      .notNullable()
      .defaultTo(true)
      .comment('Whether this tax group is active')

    // Audit fields
    table
      .uuid('created_by')
      .notNullable()
      .references('id')
      .inTable('public.users')
      .onDelete('RESTRICT')
      .comment('User who created this tax group')

    // Timestamps
    table.timestamp('created_at').defaultTo(knex.fn.now()).notNullable()
    table.timestamp('updated_at').defaultTo(knex.fn.now()).notNullable()
    table.timestamp('deleted_at').nullable()

    // Indexes
    table.index(['tenant_id', 'deleted_at'])
    table.index(['tenant_id', 'is_active'])
  })

  // Create tax_group_taxes junction table
  await knex.schema.createTable('tax_group_taxes', (table) => {
    // Primary key - UUID
    table.uuid('id').primary()

    // Foreign keys
    table
      .uuid('tax_group_id')
      .notNullable()
      .references('id')
      .inTable('tax_groups')
      .onDelete('CASCADE')
      .comment('Reference to the tax group')

    table
      .uuid('tax_id')
      .notNullable()
      .references('id')
      .inTable('taxes')
      .onDelete('CASCADE')
      .comment('Reference to the tax')

    // Order index for compound tax calculation
    table
      .integer('order_index')
      .notNullable()
      .defaultTo(0)
      .comment('Order index for tax calculation (important for compound taxes)')

    // Timestamps
    table.timestamp('created_at').defaultTo(knex.fn.now()).notNullable()
    table.timestamp('updated_at').defaultTo(knex.fn.now()).notNullable()
    table.timestamp('deleted_at').nullable()

    // Indexes
    table.index(['tax_group_id'])
    table.index(['tax_id'])
    table.index(['tax_group_id', 'order_index'])
    // Composite indexes with deleted_at for efficient soft delete queries
    table.index(['tax_group_id', 'deleted_at'])
    table.index(['tax_id', 'deleted_at'])
    table.unique(['tax_group_id', 'tax_id', 'deleted_at'])
  })
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTableIfExists('tax_group_taxes')
  await knex.schema.dropTableIfExists('tax_groups')
}
