import type { Knex } from 'knex'

/**
 * Create users table migration
 * Stores user account information
 */
export async function up(knex: Knex): Promise<void> {
  await knex.schema.createTable('users', (table) => {
    // Primary key - UUID
    // Note: UUID is generated by BaseModel.$beforeInsert() using uuidv4()
    // No database default needed as application handles UUID generation
    table.uuid('id').primary()

    // User information
    table.string('name', 255).notNullable()
    table.string('email', 255).notNullable().unique()
    table.string('password_hash', 255).notNullable()

    // Email verification
    table.boolean('is_verified').defaultTo(false).notNullable()
    table.timestamp('verified_at').nullable()

    // Multi-factor authentication
    table.boolean('mfa_enabled').defaultTo(false).notNullable()

    // Account status
    table.boolean('is_active').defaultTo(true).notNullable()

    // Authentication tracking
    table.timestamp('last_logged_in_at').nullable()

    // Timestamps
    table.timestamp('created_at').defaultTo(knex.fn.now()).notNullable()
    table.timestamp('updated_at').defaultTo(knex.fn.now()).notNullable()

    // Soft delete
    table.timestamp('deleted_at').nullable()

    // Indexes
    table.index('email')
    table.index('is_verified')
    table.index('is_active')
    table.index('deleted_at')
    // Composite indexes for common queries
    table.index(['email', 'deleted_at']) // For finding active users by email
    table.index(['is_verified', 'deleted_at']) // For finding verified active users
    table.index(['is_active', 'deleted_at']) // For finding active non-deleted users
  })
}

export async function down(knex: Knex): Promise<void> {
  // First, get all tenant schemas from the tenants table
  const tenants = await knex('tenants').select('schema_name')

  // Drop all tenant schemas first (this will automatically drop foreign key constraints)
  for (const tenant of tenants) {
    const schemaName = tenant.schema_name.startsWith('tenant_')
      ? tenant.schema_name
      : `tenant_${tenant.schema_name}`

    // Drop schema with CASCADE to remove all dependent objects
    await knex.raw(`DROP SCHEMA IF EXISTS ?? CASCADE`, [schemaName])
  }

  // Also drop any tenant schemas that might exist but aren't in the tenants table
  // (in case of orphaned schemas)
  const allSchemas = await knex.raw(`
    SELECT schema_name 
    FROM information_schema.schemata 
    WHERE schema_name LIKE 'tenant_%'
  `)

  for (const row of allSchemas.rows) {
    await knex.raw(`DROP SCHEMA IF EXISTS ?? CASCADE`, [row.schema_name])
  }

  // Now drop the tenants table
  await knex.schema.dropTableIfExists('users')
}
